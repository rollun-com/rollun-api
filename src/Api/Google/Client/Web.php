<?php
/**
 * Created by PhpStorm.
 * User: root
 * Date: 07.02.17
 * Time: 10:32
 */

namespace rollun\api\Api\Google\Client;

use rollun\api\Api\Google\Client;
use rollun\api\ApiException;
use rollun\dic\InsideConstruct;
use Zend\Diactoros\Response\RedirectResponse;
use Zend\Session\Container as SessionContainer;
use Zend\Session\SessionManager;
use Psr\Http\Message\ServerRequestInterface as Request;

class Web extends Client
{
    const KEY_CREDENTIAL = 'credential';

    const KEY_CODE = 'code';

    /** state is crypted string  */
    const KEY_STATE = 'state';

    const SECRET_PATH = 'data'
    . DIRECTORY_SEPARATOR . 'Api'
    . DIRECTORY_SEPARATOR . 'Google';

    const SECRET_FILENAME = 'client_secret.json';

    const KEY_WEB_CLIENT = 'webClient';

    /** @var  SessionContainer */
    protected $sessionContainer;

    public function __construct(array $config, $clientName, SessionContainer $sessionContainer = null)
    {
        InsideConstruct::setConstructParams(['sessionContainer' => 'WebSessionContainer']);
        if(!isset($this->sessionContainer)) {
            throw new ApiException("sessionContainer not set!");
        }
        parent::__construct($config, $clientName);
    }

    /**
     * load saved credential
     */
    protected function loadCredential()
    {
        if (isset($this->sessionContainer->{static::KEY_CREDENTIAL})) {
            $this->setAccessToken($this->sessionContainer->{static::KEY_CREDENTIAL});
            return $this->sessionContainer->{static::KEY_CREDENTIAL};
        }
        return null;
    }

    /**
     * @return bool
     */
    public function refreshAccessToken()
    {
        if (!is_null($this->getAccessToken()) && $this->isAccessTokenExpired()) {
            // save refresh token to some variable
            $refreshTokenSaved = $this->getRefreshToken();
            // update access token and pass access token to some variable
            $credential = $this->fetchAccessTokenWithRefreshToken($refreshTokenSaved);
            // append refresh token
            if (!$credential || isset($credential['error'])) {
                return false;
            }
            $credential['refresh_token'] = $refreshTokenSaved;
            $this->setAccessToken($credential);
            $this->saveCredential();
            return true;
        }
        return false;
    }

    /**
     * save credential
     * @return void
     */
    protected function saveCredential()
    {
        $this->sessionContainer->{static::KEY_CREDENTIAL} = $this->getAccessToken();
    }

    /**
     * Request authCode
     * @param $state
     * @return RedirectResponse
     */
    public function getAuthCodeRedirect($state = null)
    {
        $state = $state ?: sha1(openssl_random_pseudo_bytes(1024));
        $this->sessionContainer{static::KEY_STATE} = $state;
        $this->setState($state);
        $authUrl = $this->createAuthUrl();
        return new RedirectResponse($authUrl, 302, ['Location' => filter_var($authUrl, FILTER_SANITIZE_URL)]);
    }

    /**
     * Return user unique id.
     * An identifier for the user, unique among all Google accounts and never reused.
     * @return string|null
     */
    public function getUserId()
    {
        $token = $this->getAccessToken();
        $idToken = $token['id_token'];
        if ($this->verifyIdToken($idToken)) {
            $tokenParams = explode('.', $idToken);
            list($headb64, $bodyb64, $cryptob64) = $tokenParams;
            $payload = json_decode(base64_decode($bodyb64));
            return $payload->sub;
        }
        return null;
    }

    /**
     * @param $authCode
     * @return bool
     */
    public function authByCode($authCode)
    {
        if (isset($authCode)) {
            $credential = $this->fetchAccessTokenWithAuthCode($authCode);
            if (!$credential || isset($creds['error'])) {
                return false;
            }
            $this->saveCredential();
            return true;
        }
        return false;
    }

    public function getResponseState()
    {
        return $this->sessionContainer->{static::KEY_STATE};
    }

    /**
     * @param null $token
     * @return bool
     */
    public function revokeToken($token = null)
    {
        unset($this->sessionContainer->{static::KEY_CREDENTIAL});
        unset($this->sessionContainer->{static::KEY_STATE});
        return parent::revokeToken($token); // TODO: Change the autogenerated stub
    }


}
