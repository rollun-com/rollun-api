# Библиотека для работы с Megaplan API.

## Быстрый старт

### Установка

С помощью команды `composer lib install` запустите инсталлер библиотеки: MegaplanInstaller.

В папке config/autoload должен появиться файл **rollun.api.Api.Megaplan.Megaplan.dist.local.php**.
Заполните те секции конфига, которые не входят в раздел dependencies. После этого библиотека готова к работе.

### Разделы конфигурации

1. **megaplan**. Настройка доступа к серверу Мегаплана. Здесь нужно ввести название Мегаплана, логин и пароль доступа.
2. **megaplan_entities**. Здесь заполняются сервисы-обертки для доступа к API Мегаплана.
Каждый сервис содержит 4 обязательных параметра:
- **entity**. Какой тип сущностей нужно будет получить при запросе к Мегаплану. Заполнять нужно
по имени класса сущности (доступные сущности можно посмотреть в папке rollun-api/src/Api/src/Api/Megaplan/Entity).
- **dataStore**. Сервис, который описывает, в какой именно тип dataStore будет записываться результат.
- **serializer**. Данные от Мегаплана приходят в специальном формате. Данный сериалайзер призван выполнить
рутинные действия по извлечению этих данных из этой структуры и подготовке их к записи в dataStore.
- **serializerOptions**. Настройки для сериалайзера.

Два последних параметра ссылаются на одноименные псевдонимы (секция aliases).

3. **dataStore**. Собственно, раздел, где описываются сервисы dataStore для их дальнейшего использования.
Нужно раличать этот раздел с одноименным разделом из секции megaplan_entities.


### Использование.
```
// some_entity_service - это сервис, описанный в файле конфигурации (см.выше)
$megaplanClient = $container->get('some_entity_service');

// $result будет содержать массив с развернутыми сущностями в виде,
// который полностью готов для записи в dataStore без дополнительных действий
// При выполнении этого метода результат также будет записан в dataStore
$result = $megaplanClient->get();
```


## Serializer
Как было сказано выше, данные от Мегаплана приходят в специалном формате (на примере Сделок):
```
Array
(
    [status] => Array
        (
            [code] => ok
            [message] =>
        )
    [data] => Array
        (
            [deals] => Array
                (
                    [0] => Array
                        (
                            // Deal data
                        )
                    [1] => Array
                        (
                            // Deal data
                        )
                    // ...
                    [N] => Array
                        (
                            // Deal data
                        )
                )
        )
)
```
Кроме того, весь этот массив приходит в виде JSON-строки. Задачи сериалайзера развернуть
этот массив, затем извлечь сами Сделки (['data']['deals']), а затем подготовить эти данные
к записи в dataStore.

По умолчанию используется класс сериализатора **\rollun\api\Api\Megaplan\Serializer\Megaplan**
и класс его настроек **\rollun\api\Api\Megaplan\Serializer\MegaplanOptions**. Класс сериализатора
реализует интерфейс **\Zend\Serializer\Adapter\AdapterInterface**; при желании можно не писать
этот класс с нуля, а отнаследоваться от класса \Zend\Serializer\Adapter\AbstractAdapter.

Сериализатор **\rollun\api\Api\Megaplan\Serializer\Megaplan** требует обязательного наличия класса настроек.
Такой класс должен обязательно реализовавыть интерфейс **\rollun\api\Api\Megaplan\Serializer\MegaplanOptionsInterface**.
Это необходимо, чтобы передавать в сериализатор тип сущности Мегаплана, с которым он (сериализатор) будет работать.
Как и в случае с основным классом, можно не писать класс настроек с нуля, а отнаследоваться от класса
**\rollun\api\Api\Megaplan\Serializer\MegaplanOptions**.


## Фабрика для клиента Мегаплана
Сам Мегаплан предоставляет очень удобный клиент для PHP. Он инкапсулирует очень много рутинных действий для отправки
запроса серверу. Но тем не менее, даже используя этот клиент нужно совершить еще минимум три дополнительных действия,
прежде чем удастся отправить запрос на сервер.

Поэтому для оригинального клиента Мегаплана была создана наша собственная фабрика, которая вычитывает конфиг,
создает объект MegaplanClient и авторизует его на сервере Мегаплана. Такой подход позволяет использовать клиент с разными
настройками доступа и передавать его в виде зависимости в другие классы/фабрики.

Класс фабрики: **\rollun\api\Api\Megaplan\Entity\Factory\MegaplanClientFactory**.


## Сущности Мегаплана
### Как все работает
Весь API Мегаплана построен на работе вокруг сущностей (Сделки, Заказы, Задачи и тд). При запросе к серверу нужно указать
нужный URI для получения той или иной сущности - каждую сущность обслуживает отдельный URI.

В нашей библиотеке базовой сущностью для всех является абстрактный класс **\rollun\api\Api\Megaplan\Entity\EntityAbstract**.
По сути, она делает всю работу. В классе содержится набор констант, которые должен переопределять класс-наследник:
- **URI_ENTITY_GET**; URI, который обслуживает данную сущность.
- **ENTITY_LIST_KEY**; ключ массива в ответе с сервера, где будут содержаться запрошенные данные.
- **MAX_LIMIT**; максимальный лимит получаемых данных. Чисто технический параметр. Дело в том, что сам **Мегаплан НЕ
отпускает более 100 строк ответа за один запрос**. Если сущностей ожидается больше, то нужно выполнять смещение с помощью
параметра запроса 'Offset'. Здесь эта константа не требует переопределения (хотя и может быть переопределена). Она нужна
для правильной работы цикла выборки с нашей стороны. Переопределение ее в бОльшую сторону не имеет смысла и приведет к
ошибке во время выполнения запроса.
- **REQUESTED_FIELDS**; требуемые поля (см. справку Мегаплана). Если не указать это значение или указать ему пустой массив,
то этот ключ игнорируется.
- **EXTRA_FIELDS**; дополнительные поля (см. справку Мегаплана). Если не указать это значение или указать ему пустой массив,
то этот ключ игнорируется.

Кроме конструктора, класс предоставляет всего один публичный метод - **get()**. Он не получает параметров - все параметры
обозначены в вышеупомянутых константах. В этом методе производится выборка данных, их развертывание и преобразование,
запись в dataStore и возврат результирующего массива (того, который в предыдущем шаге был записан в dataStore).

### Как создать новую сущность?
Для этого достаточно отнаследоваться от базового класса сущностей **\rollun\api\Api\Megaplan\Entity\EntityAbstract**
и переопределить вышеуказанные константы на реальные значения.

Как именно будет назван новый класс, не имеет значения. А вот то, что будет указано в константах, имеет реальный смысл.